## 扩展欧几里得算法

求$ax+by=\gcd(a,b)$的一组解，函数返回值是$\gcd(a,b)$，x,y在迭代中途求解
该函数也可用于求逆元，因为a、b互素的时候求解$ax+by=1$，即 $ax \equiv 1 \pmod{b}$，但$x$有可能是负数
```cpp
typedef long long ll;
ll Exgcd(ll a, ll b, ll& x, ll& y) {
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    ll d = Exgcd(b, a % b, y, x);
	y -= a / b * x;
    return d;
}
```

扩欧求解线性同余方程$ax\equiv c \pmod{b}$,，转化成$ax+by=c$求解，函数返回是否有解，x,y是$ax+by=c$的一组解，通解$x=x_0+bt$ ; $y=y_0-at$ ($t$取任意整数)
```cpp
bool liEu(int a, int b, int c, int& x, int& y) {
    int d = Exgcd(a, b, x, y);
    if (c % d != 0) return false;
    int k = c / d;
    x *= k;
    y *= k;
    return true;
}
```

## 中国剩余定理
求解线性同余方程组$x\equiv a_i \pmod{r_i}$
```cpp
typedef long long ll;//很可能long long也会爆，要开__int128
ll CRT(vector<ll> &r, vector<ll> &a) {
    ll n = 1, ans = 0, k = a.size();
    for (auto x : r) n = n * x;
    for (int i = 0; i < k; i++) {
        ll m = n / r[i], R, y;
        Exgcd(m, r[i], R, y);  // 见扩欧模版
        ans = (ans + a[i] * m * R % n) % n;
    }
    return (ans % n + n) % n;
}
```

## 扩展中国剩余定理
处理模数不互质的情况
```cpp
ll ExCRT(vector<ll>&r,vector<ll>&a) {
	ll R = r[1], A = a[1];
	auto mix = [&](ll aa, ll rr) {
		ll x, y;
		liEu(R, rr, aa - A, x, y);
		A += R * x;
		R = lcm(R, rr);
		A %= R;
		if (A < 0)A += R;
		};
	for (int i = 2; i < r.size(); i++)
		mix(a[i], r[i]);
	ll ans = A % R;
	if (ans < 0)ans += R;
	return ans;
}
```

## Min_25筛
用途：定义积性函数 $f(x)$，求解$\sum_{i = 1} ^ n f(i)$
使用说明：要将$f(x)$多项式拆成单项式，然后分别计算递推函数g
下板题意为：定义积性函数 $f(x)$，且 $f(p ^ k) = p ^ k(p ^ k - 1)$（$p$ 是一个质数）
```cpp
void min_25(int n) {
	const int MOD = 1000000007, inv2 = 500000004, inv3 = 333333336; //inv2、inv3分别表示2和3的逆元，公式需要
	int sq = sqrt(n);
	vector<int>g1(sq * 3), g2(sq * 3); //递推函数,数量依据多项式拆出来的单项式个数
	vector<int>sp1(sq * 3), sp2(sq * 3); //前i项质数的多项式前缀和
	vector<int>w(sq * 3); //离散化存储要处理的数
	vector<int>idx1(sq * 3), idx2(sq * 3);//记录离散化下标
	
	auto getPrime = [&](int n){
			vector <bool> vis(n + 1);
			vector <int> prime;
			prime.push_back(1);
			vis[1] = 1;
			for (int i = 2; i <= n; ++i) {
				if (!vis[i]) { 
					prime.push_back(i); 
					sp1[prime.size() - 1] = (sp1[prime.size() - 2] + i) % MOD;
					sp2[prime.size() - 1] = (sp2[prime.size() - 2] + i * i) % MOD;
					//求素数的函数和
				}
				for (auto p : prime) {
					if (p > 1) {
						if (i * p > n) { break; }
						vis[i * p] = 1;
						if (i % p == 0) { break; }
					}
				}
			}
			
			return prime;
	};

	vector<int> p = getPrime(sq);
	function<int(int, int)> S = [&](int x, int y) ->int {
		if (p[y] >= x)return 0;
		int k = (x <= sq ? idx1[x] : idx2[n / x]);
		int ans = (g2[k] - g1[k] + MOD - (sp2[y] - sp1[y]) + MOD) % MOD;//质数贡献
		for (int i = y + 1; i < p.size() && p[i] * p[i] <= x; i++)//合数贡献
		{
			int pe = p[i];
			for (int e = 1; pe <= x; e++, pe = pe * p[i])
			{
				int xx = pe % MOD;
				ans = (ans + xx * (xx - 1) % MOD * (S(x / pe, i) + (e != 1))) % MOD;
			}
		}
		return ans % MOD;
	};
	int d = 0, cnt = 0;
	while (d < n) {
		d++;
		w[++cnt] = n / d;
		int tmp = w[cnt] % MOD;
		
		//全部初始化为g(i,0)，即函数前缀和(包括素数和合数)
		g2[cnt] = tmp * (tmp + 1) / 2 % MOD * (2 * tmp + 1) % MOD * inv3 % MOD - 1;//平方和公式，因为p0=1，所以要把1去掉
		g1[cnt] = tmp * (tmp + 1) / 2 % MOD - 1;

		//数论分块
		if (n / d <= sq)idx1[n / d] = cnt;
		else idx2[n / (n / d)] = cnt;
		d = n / (n / d);
	}
	
	for (int i = 1; i < p.size();i++) 
		for (int j = 1; j <= cnt && p[i] * p[i] <= w[j]; j++)
		{
			int k = (w[j] / p[i] <= sq ? idx1[w[j] / p[i]] : idx2[n / (w[j] / p[i])]);
			g1[j] -= p[i] * (g1[k] - sp1[i - 1] + MOD) % MOD;
			g2[j] -= p[i] * p[i] % MOD * (g2[k] - sp2[i - 1] + MOD) % MOD;
			g1[j] %= MOD, g2[j] %= MOD;
			if (g1[j] < 0)g1[j] += MOD;
			if (g2[j] < 0)g2[j] += MOD;
		}
	cout << (S(n, 0) + 1) % MOD;
}
```

也可以用于求非积性函数的质数项前缀和，只需最后计算S的时候去掉合数的贡献即可，例如：Min_25筛求区间素数个数(即n以内素数个数)
```cpp
int min_25(int n) {
	int sq = sqrt(n);
	vector<int>g1(sq * 3);
	vector<int>sp1(sq * 3);
	vector<int>w(sq * 3); 
	vector<int>idx1(sq * 3), idx2(sq * 3);
	auto getPrime = [&](int n) {
		vector <bool> vis(n + 1);
		vector <int> prime;
		prime.push_back(1);
		vis[1] = 1;
		for (int i = 2; i <= n; ++i) {
			if (!vis[i]) {
				prime.push_back(i);
				sp1[prime.size() - 1] = (sp1[prime.size() - 2] + 1);
			}
			for (auto p : prime) {
				if (p > 1) {
					if (i * p > n) { break; }
					vis[i * p] = 1;
					if (i % p == 0) { break; }
				}
			}
		}
		return prime;
	};
	vector<int> p = getPrime(sq);
	function<int(int, int)> S = [&](int x, int y) ->int {
		if (p[y] >= x)return 0;
		int k = (x <= sq ? idx1[x] : idx2[n / x]);
		int ans = g1[k] -sp1[y];
		return ans;
		};
	int d = 0, cnt = 0;
	while (d < n) {
		d++;
		w[++cnt] = n / d;
		int tmp = w[cnt];
		g1[cnt] = tmp - 1;
		if (n / d <= sq)idx1[n / d] = cnt;
		else idx2[n / (n / d)] = cnt;
		d = n / (n / d);
	}

	for (int i = 1; i < p.size(); i++)
		for (int j = 1; j <= cnt && p[i] * p[i] <= w[j]; j++)
		{
			int k = (w[j] / p[i] <= sq ? idx1[w[j] / p[i]] : idx2[n / (w[j] / p[i])]);
			g1[j] -= g1[k] - sp1[i - 1];
		}
	return S(n, 0);
}
```

## Lucas定理
在模数较小的情况下快速计算排列组合数
```cpp
typedef long long ll;
ll Lucas(ll n, ll k, ll p) { 
	if (k == 0) return 1; 
	return (C(n % p, k % p, p) * Lucas(n / p, k / p, p)) % p; 
}
```